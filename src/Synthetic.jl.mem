        - module Synthetic
        - 
        - export gen_blob
        - 
        - using CelesteTypes
        - import ModelInit
        - import Util
        - import WCS
        - 
        - import Distributions
        - 
        - # Generate synthetic data.
        - 
        - function wrapped_poisson(rate::Float64)
        0     0 < rate ? float(rand(Distributions.Poisson(rate))) : 0.
        - end
        - 
        - 
        - function get_patch(the_mean::Vector{Float64}, H::Int64, W::Int64)
        0     const radius = 50
        0     hm = round(Int, the_mean[1])
        0     wm = round(Int, the_mean[2])
        0     w11 = max(1, wm - radius):min(W, wm + radius)
        0     h11 = max(1, hm - radius):min(H, hm + radius)
        0     return(w11, h11)
        - end
        - 
        - 
        - function write_gaussian(the_mean, the_cov, intensity, pixels;
        -                         expectation=false)
        0     the_precision = the_cov^-1
        0     c = det(the_precision)^.5 / 2pi
        0     y = Array(Float64, 2)
        - 
        0     H, W = size(pixels)
        0     w_range, h_range = get_patch(the_mean, H, W)
        - 
        0     for w in w_range, h in h_range
        0         y[1] = the_mean[1] - h
        0         y[2] = the_mean[2] - w
        0         ypy = Util.matvec222(the_precision, y)
        0         pdf_hw = c * exp(-0.5 * ypy)
        0         pixel_rate = intensity * pdf_hw
        0         pixels[h, w] += expectation ? pixel_rate : wrapped_poisson(pixel_rate)
        -     end
        - 
        0     pixels
        - end
        - 
        - 
        - function write_star(img0::Image, ce::CatalogEntry, pixels::Matrix{Float64};
        -                     expectation=false)
        0     for k in 1:length(img0.psf)
        0         the_mean = WCS.world_to_pixel(img0.wcs, ce.pos) + img0.psf[k].xiBar
        0         the_cov = img0.psf[k].tauBar
        0         intensity = ce.star_fluxes[img0.b] * img0.iota * img0.psf[k].alphaBar
        0         write_gaussian(the_mean, the_cov, intensity, pixels,
        -             expectation = expectation)
        -     end
        - end
        - 
        - 
        - function write_galaxy(img0::Image, ce::CatalogEntry, pixels::Matrix{Float64};
        -                       expectation=false)
        0     e_devs = [ce.gal_frac_dev, 1 - ce.gal_frac_dev]
        - 
        0     XiXi = Util.get_bvn_cov(ce.gal_ab, ce.gal_angle, ce.gal_scale)
        - 
        0     for i in 1:2
        0         for gproto in galaxy_prototypes[i]
        0             for k in 1:length(img0.psf)
        0                 the_mean = WCS.world_to_pixel(img0.wcs, ce.pos) +
        -                            img0.psf[k].xiBar
        0                 the_cov = img0.psf[k].tauBar + gproto.nuBar * XiXi
        0                 intensity = ce.gal_fluxes[img0.b] * img0.iota *
        -                     img0.psf[k].alphaBar * e_devs[i] * gproto.etaBar
        0                 write_gaussian(the_mean, the_cov, intensity, pixels,
        -                     expectation=expectation)
        -             end
        -         end
        -     end
        - end
        - 
        - function gen_image(img0::Image, n_bodies::Vector{CatalogEntry}; expectation=false)
        0     if expectation
        0         pixels = [ img0.epsilon * img0.iota for h=1:img0.H, w=1:img0.W ]
        -     else
        0         pixels = reshape(float(rand(Distributions.Poisson(img0.epsilon * img0.iota),
        -                          img0.H * img0.W)), img0.H, img0.W)
        -     end
        - 
        0     for body in n_bodies
        0         body.is_star ? write_star(img0, body, pixels) : write_galaxy(img0, body, pixels)
        -     end
        - 
        0     return Image(img0.H, img0.W, pixels, img0.b, img0.wcs, img0.epsilon,
        -                  img0.iota, img0.psf, img0.run_num, img0.camcol_num, img0.field_num)
        - end
        - 
        - @doc """
        - Generate a simulated blob based on a vector of catalog entries using
        - identity world coordinates.
        - """ ->
        - function gen_blob(blob0::Blob, n_bodies::Vector{CatalogEntry}; expectation=false)
        0     [gen_image(blob0[b], n_bodies, expectation=expectation) for b in 1:5]
        - end
        - 
        - 
        - #######################################
        - 
        - const pp = ModelInit.sample_prior()
        - 
        - 
        - function sample_fluxes(i::Int64, r_s)
        - #    r_s = rand(Distributions.Normal(pp.r_mean[i], pp.r_var[i]))
        -     k_s = rand(Distributions.Categorical(pp.k[i]))
        -     c_s = rand(Distributions.MvNormal(pp.c[i][:, k_s], pp.c[i][:, :, k_s]))
        - 
        -     l_s = Array(Float64, 5)
        -     l_s[3] = r_s
        -     l_s[4] = l_s[3] * exp(c_s[3])
        -     l_s[5] = l_s[4] * exp(c_s[4])
        -     l_s[2] = l_s[3] / exp(c_s[2])
        -     l_s[1] = l_s[2] / exp(c_s[1])
        -     l_s
        - end
        - 
        - 
        - function synthetic_body(ce::CatalogEntry)
        -     ce2 = deepcopy(ce)
        - #    ce2.is_star = rand(Distributions.Bernoulli(pp.a[1]))
        -     ce2.star_fluxes[:] = sample_fluxes(1, ce.star_fluxes[3])
        -     ce2.gal_fluxes[:] = sample_fluxes(2, ce.gal_fluxes[3])
        -     ce2
        - end
        - 
        - 
        - function synthetic_bodies(n_bodies::Vector{CatalogEntry})
        -     CatalogEntry[synthetic_body(ce) for ce in n_bodies]
        - end
        - 
        - 
        - end
        - 
